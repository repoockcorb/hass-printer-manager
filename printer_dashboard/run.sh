#!/bin/bash
set -e

# ==============================================================================
# Start the Printer Dashboard add-on
# ==============================================================================

echo "[INFO] Starting Printer Dashboard..."

# Export environment variables for the Flask app
export SUPERVISOR_TOKEN="${SUPERVISOR_TOKEN}"
export HASSIO_TOKEN="${HASSIO_TOKEN}"
export HOME_ASSISTANT_URL="http://supervisor/core"

# Create data directory if it doesn't exist
mkdir -p /data

# -----------------------------------------------------------------------------
# Generate dynamic nginx proxy config for printers
# -----------------------------------------------------------------------------
PRINTERS_JSON="/data/options.json"
NGINX_UPSTREAMS="/etc/nginx/conf.d/printers_upstreams.conf"
NGINX_LOCATIONS="/etc/nginx/conf.d/printers_locations.conf"

mkdir -p /etc/nginx/conf.d

echo "# autogenerated upstreams on $(date)" > "$NGINX_UPSTREAMS"
echo "# autogenerated locations on $(date)" > "$NGINX_LOCATIONS"

# Iterate over printers array (if any)
if [ -f "$PRINTERS_JSON" ]; then
    PRINTER_COUNT=$(jq '.printers | length' "$PRINTERS_JSON" 2>/dev/null || echo 0)
    if [ "$PRINTER_COUNT" -gt 0 ]; then
        jq -c '.printers[]' "$PRINTERS_JSON" | while read -r PRN; do
            NAME=$(echo "$PRN" | jq -r '.name' | tr ' ' '_' | tr '[:upper:]' '[:lower:]')
            URL=$(echo  "$PRN" | jq -r '.url')

            # if url is relative (starts with /proxy/) skip, it already targets proxy
            if echo "$URL" | grep -qE '^https?://'; then
                # strip protocol and possible trailing slash
                HOST=$(echo "$URL" | sed -E 's#^https?://##' | sed 's#/*$##')

                cat >> "$NGINX_UPSTREAMS" <<EOF

upstream ${NAME}_up {
    server ${HOST};
}

EOF

                cat >> "$NGINX_LOCATIONS" <<EOF

# Handle trailing slash redirect for ${NAME}
location = /proxy/${NAME} {
    return 301 /proxy/${NAME}/;
}

location /proxy/${NAME}/ {
    proxy_pass         http://${NAME}_up/;
    proxy_set_header   Host \$http_host;
    proxy_set_header   X-Real-IP \$remote_addr;
    proxy_set_header   X-Forwarded-For \$proxy_add_x_forwarded_for;
    proxy_set_header   X-Forwarded-Proto \$scheme;
    proxy_set_header   X-Forwarded-Host \$host;
    proxy_set_header   X-Forwarded-Port \$server_port;
    proxy_http_version 1.1;
    proxy_buffering    off;
    
    # Handle WebSocket upgrades
    proxy_set_header   Upgrade \$http_upgrade;
    proxy_set_header   Connection \$connection_upgrade;
    
    # Add error logging
    error_log /dev/stdout warn;
    access_log /dev/stdout;
    
    # Timeout settings
    proxy_connect_timeout 10s;
    proxy_send_timeout 10s;
    proxy_read_timeout 10s;
    
    # Handle redirects properly
    proxy_redirect     default;
    proxy_redirect     http://\$host/ /proxy/${NAME}/;
    proxy_redirect     https://\$host/ /proxy/${NAME}/;
}

EOF
            fi
        done
    fi
fi

echo "[INFO] Generated dynamic printer proxy config:"
cat "$NGINX_UPSTREAMS"
cat "$NGINX_LOCATIONS"

# Test connectivity to printer interfaces
echo "[INFO] Testing connectivity to printer interfaces..."
if [ -f "$PRINTERS_JSON" ]; then
    PRINTER_COUNT=$(jq '.printers | length' "$PRINTERS_JSON" 2>/dev/null || echo 0)
    if [ "$PRINTER_COUNT" -gt 0 ]; then
        jq -c '.printers[]' "$PRINTERS_JSON" | while read -r PRN; do
            NAME=$(echo "$PRN" | jq -r '.name')
            URL=$(echo  "$PRN" | jq -r '.url')
            
            if echo "$URL" | grep -qE '^https?://'; then
                echo "[DEBUG] Testing connection to $NAME at $URL..."
                if timeout 5 curl -s -o /dev/null -w "%{http_code}" "$URL" >/dev/null 2>&1; then
                    echo "[INFO] ✓ $NAME ($URL) is reachable"
                else
                    echo "[WARN] ✗ $NAME ($URL) is not reachable - this may cause 404 errors"
                fi
            fi
        done
    fi
fi

# -----------------------------------------------------------------------------
# Configure nginx on each printer for base path support
# -----------------------------------------------------------------------------
configure_printer_nginx() {
    local PRINTER_IP="$1"
    local PRINTER_NAME="$2"
    local SSH_USER="$3"
    local SSH_PASS="$4"
    local SSH_KEY="$5"
    
    echo "[INFO] Configuring nginx on $PRINTER_NAME ($PRINTER_IP)..."
    
    # Create the nginx configuration for this printer
    local NGINX_CONFIG=$(cat <<EOF
# Mainsail configuration with base path support - Auto-generated by Printer Dashboard Add-on
upstream apiserver {
    ip_hash;
    server 127.0.0.1:7125;
}

upstream mjpgstreamer1 {
    ip_hash;
    server 127.0.0.1:8080;
}

upstream mjpgstreamer2 {
    ip_hash;
    server 127.0.0.1:8081;
}

upstream mjpgstreamer3 {
    ip_hash;
    server 127.0.0.1:8082;
}

upstream mjpgstreamer4 {
    ip_hash;
    server 127.0.0.1:8083;
}

map \$http_upgrade \$connection_upgrade {
    default upgrade;
    '' close;
}

server {
    listen 80 default_server;
    
    access_log /var/log/nginx/mainsail-access.log;
    error_log /var/log/nginx/mainsail-error.log;
    
    # Disable max upload size checks
    client_max_body_size 0;
    
    # Original root location (backward compatibility)
    location / {
        root /home/pi/mainsail;
        index index.html;
        try_files \$uri \$uri/ /index.html;
    }
    
    # Base path location for Home Assistant proxy
    location /proxy/${PRINTER_NAME}/ {
        alias /home/pi/mainsail/;
        index index.html;
        try_files \$uri \$uri/ /proxy/${PRINTER_NAME}/index.html;
        
        # Rewrite absolute paths in HTML/CSS/JS to include base path
        sub_filter 'href="/' 'href="/proxy/${PRINTER_NAME}/';
        sub_filter 'src="/' 'src="/proxy/${PRINTER_NAME}/';
        sub_filter 'url(/' 'url(/proxy/${PRINTER_NAME}/';
        sub_filter '"/api/' '"/proxy/${PRINTER_NAME}/api/';
        sub_filter '"/printer/' '"/proxy/${PRINTER_NAME}/printer/';
        sub_filter '"/machine/' '"/proxy/${PRINTER_NAME}/machine/';
        sub_filter '"/server/' '"/proxy/${PRINTER_NAME}/server/';
        sub_filter '"/access/' '"/proxy/${PRINTER_NAME}/access/';
        sub_filter '"/websocket' '"/proxy/${PRINTER_NAME}/websocket';
        sub_filter_once off;
        sub_filter_types text/html text/css application/javascript application/json;
    }
    
    # API endpoints with base path
    location ~ ^/proxy/${PRINTER_NAME}/(websocket|printer|api|access|machine|server)/(.*) {
        proxy_pass http://apiserver/\$1/\$2\$is_args\$args;
        proxy_set_header Host \$http_host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection \$connection_upgrade;
        proxy_http_version 1.1;
        proxy_buffering off;
        proxy_request_buffering off;
    }
    
    # Original API endpoints (backward compatibility)
    location /websocket {
        proxy_pass http://apiserver/websocket;
        proxy_set_header Host \$http_host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection \$connection_upgrade;
        proxy_http_version 1.1;
        proxy_buffering off;
        proxy_request_buffering off;
    }
    
    location ~ ^/(printer|api|access|machine|server)/ {
        proxy_pass http://apiserver\$request_uri;
        proxy_set_header Host \$http_host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_http_version 1.1;
        proxy_buffering off;
        proxy_request_buffering off;
    }
    
    # Webcam streams with base path
    location ~ ^/proxy/${PRINTER_NAME}/webcam(\d*)/(.*) {
        proxy_pass http://mjpgstreamer\$1/\$2;
        proxy_set_header Host \$http_host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_http_version 1.1;
        proxy_buffering off;
        proxy_request_buffering off;
    }
    
    # Original webcam streams (backward compatibility)
    location ~ ^/webcam(\d*)/(.*) {
        proxy_pass http://mjpgstreamer\$1/\$2;
        proxy_set_header Host \$http_host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_http_version 1.1;
        proxy_buffering off;
        proxy_request_buffering off;
    }
}
EOF
)
    
    # Determine SSH method
    local SSH_CMD=""
    if [ -n "$SSH_KEY" ]; then
        # Use SSH key
        echo "$SSH_KEY" > /tmp/ssh_key
        chmod 600 /tmp/ssh_key
        SSH_CMD="ssh -i /tmp/ssh_key -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null"
    elif [ -n "$SSH_PASS" ]; then
        # Use password
        SSH_CMD="sshpass -p '$SSH_PASS' ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null"
    else
        echo "[WARN] No SSH credentials provided for $PRINTER_NAME - skipping nginx configuration"
        return 1
    fi
    
    # Upload and apply the configuration
    echo "[DEBUG] Uploading nginx configuration to $PRINTER_NAME..."
    if echo "$NGINX_CONFIG" | $SSH_CMD $SSH_USER@$PRINTER_IP "sudo tee /etc/nginx/sites-available/mainsail > /dev/null"; then
        echo "[DEBUG] Testing nginx configuration on $PRINTER_NAME..."
        if $SSH_CMD $SSH_USER@$PRINTER_IP "sudo nginx -t"; then
            echo "[DEBUG] Reloading nginx on $PRINTER_NAME..."
            if $SSH_CMD $SSH_USER@$PRINTER_IP "sudo systemctl reload nginx"; then
                echo "[INFO] ✓ Successfully configured nginx on $PRINTER_NAME"
                return 0
            else
                echo "[ERROR] Failed to reload nginx on $PRINTER_NAME"
                return 1
            fi
        else
            echo "[ERROR] Invalid nginx configuration for $PRINTER_NAME"
            return 1
        fi
    else
        echo "[ERROR] Failed to upload nginx configuration to $PRINTER_NAME"
        return 1
    fi
    
    # Cleanup
    [ -f /tmp/ssh_key ] && rm -f /tmp/ssh_key
}

# Configure nginx on each printer
echo "[INFO] Configuring nginx on printers for base path support..."
if [ -f "$PRINTERS_JSON" ]; then
    SSH_USERNAME=$(jq -r '.ssh_username // "pi"' "$PRINTERS_JSON")
    SSH_PASSWORD=$(jq -r '.ssh_password // ""' "$PRINTERS_JSON")
    SSH_KEY=$(jq -r '.ssh_key // ""' "$PRINTERS_JSON")
    
    PRINTER_COUNT=$(jq '.printers | length' "$PRINTERS_JSON" 2>/dev/null || echo 0)
    if [ "$PRINTER_COUNT" -gt 0 ]; then
        jq -c '.printers[]' "$PRINTERS_JSON" | while read -r PRN; do
            NAME=$(echo "$PRN" | jq -r '.name' | tr ' ' '_' | tr '[:upper:]' '[:lower:]')
            URL=$(echo  "$PRN" | jq -r '.url')
            
            if echo "$URL" | grep -qE '^https?://'; then
                # Extract IP from URL
                PRINTER_IP=$(echo "$URL" | sed -E 's#^https?://([^:/]+).*#\1#')
                
                if configure_printer_nginx "$PRINTER_IP" "$NAME" "$SSH_USERNAME" "$SSH_PASSWORD" "$SSH_KEY"; then
                    echo "[INFO] ✓ Printer $NAME nginx configured successfully"
                else
                    echo "[WARN] ✗ Failed to configure nginx on $NAME - manual configuration may be required"
                fi
            fi
        done
    fi
fi

# Start nginx in background
echo "[INFO] Starting nginx..."
nginx &

# Function to handle shutdown gracefully
shutdown() {
    echo "[INFO] Shutting down services..."
    pkill -f "python3 app.py" || true
    pkill nginx || true
    exit 0
}

# Trap signals for graceful shutdown
trap shutdown SIGTERM SIGINT

# Start the Flask application in foreground
echo "[INFO] Starting Python Flask backend..."
cd /app
python3 app.py &

# Wait for background processes
wait 