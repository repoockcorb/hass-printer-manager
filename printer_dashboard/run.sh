#!/bin/bash
set -e

# ==============================================================================
# Start the Printer Dashboard add-on
# ==============================================================================

echo "[INFO] Starting Printer Dashboard..."

# Export environment variables for the Flask app
export SUPERVISOR_TOKEN="${SUPERVISOR_TOKEN}"
export HASSIO_TOKEN="${HASSIO_TOKEN}"
export HOME_ASSISTANT_URL="http://supervisor/core"

# Create data directory if it doesn't exist
mkdir -p /data

# -----------------------------------------------------------------------------
# Generate dynamic nginx proxy config for printers
# -----------------------------------------------------------------------------
PRINTERS_JSON="/data/options.json"
NGINX_UPSTREAMS="/etc/nginx/conf.d/printers_upstreams.conf"
NGINX_LOCATIONS="/etc/nginx/conf.d/printers_locations.conf"

mkdir -p /etc/nginx/conf.d

echo "# autogenerated upstreams on $(date)" > "$NGINX_UPSTREAMS"
echo "# autogenerated locations on $(date)" > "$NGINX_LOCATIONS"

# Iterate over printers array (if any)
if [ -f "$PRINTERS_JSON" ]; then
    PRINTER_COUNT=$(jq '.printers | length' "$PRINTERS_JSON" 2>/dev/null || echo 0)
    if [ "$PRINTER_COUNT" -gt 0 ]; then
        jq -c '.printers[]' "$PRINTERS_JSON" | while read -r PRN; do
            NAME=$(echo "$PRN" | jq -r '.name' | tr ' ' '_' | tr '[:upper:]' '[:lower:]')
            URL=$(echo  "$PRN" | jq -r '.url')

            # if url is relative (starts with /proxy/) skip, it already targets proxy
            if echo "$URL" | grep -qE '^https?://'; then
                # strip protocol and possible trailing slash
                HOST=$(echo "$URL" | sed -E 's#^https?://##' | sed 's#/*$##')

                cat >> "$NGINX_UPSTREAMS" <<EOF

upstream ${NAME}_up {
    server ${HOST};
}

EOF

                cat >> "$NGINX_LOCATIONS" <<EOF

# Handle trailing slash redirect for ${NAME}
location = /proxy/${NAME} {
    return 301 /proxy/${NAME}/;
}

location /proxy/${NAME}/ {
    # Proxy to the printer
    proxy_pass         http://${NAME}_up/;
    proxy_set_header   Host \$http_host;
    proxy_set_header   X-Real-IP \$remote_addr;
    proxy_set_header   X-Forwarded-For \$proxy_add_x_forwarded_for;
    proxy_set_header   X-Forwarded-Proto \$scheme;
    proxy_set_header   X-Forwarded-Host \$host;
    proxy_set_header   X-Forwarded-Port \$server_port;
    proxy_http_version 1.1;
    proxy_buffering    off;
    
    # Allow OctoPrint and other UIs to be embedded in iframe
    proxy_hide_header  X-Frame-Options;
    proxy_hide_header  Content-Security-Policy;
    add_header         X-Frame-Options "ALLOWALL";
    add_header         Content-Security-Policy "frame-ancestors *";
    
    # Handle WebSocket upgrades
    proxy_set_header   Upgrade \$http_upgrade;
    proxy_set_header   Connection \$connection_upgrade;
    
    # Add error logging
    error_log /dev/stdout warn;
    access_log /dev/stdout;
    
    # Timeout settings
    proxy_connect_timeout 10s;
    proxy_send_timeout 10s;
    proxy_read_timeout 10s;
    
    # Handle redirects properly
    proxy_redirect     default;
    proxy_redirect     http://\$host/ /proxy/${NAME}/;
    proxy_redirect     https://\$host/ /proxy/${NAME}/;
    
    # Comprehensive content rewriting for HTML
    sub_filter 'href="/' 'href="/proxy/${NAME}/';
    sub_filter 'src="/' 'src="/proxy/${NAME}/';
    sub_filter 'url("/' 'url("/proxy/${NAME}/';
    sub_filter 'url(/' 'url(/proxy/${NAME}/';
    sub_filter "href='/" "href='/proxy/${NAME}/";
    sub_filter "src='/" "src='/proxy/${NAME}/";
    sub_filter 'action="/' 'action="/proxy/${NAME}/';
    sub_filter 'from"/' 'from"/proxy/${NAME}/';
    sub_filter '"/' '"/proxy/${NAME}/';
    sub_filter "'/" "'/proxy/${NAME}/";
    sub_filter_once off;
    sub_filter_types text/html;
}

EOF
            fi
        done
    fi
fi

echo "[INFO] Generated dynamic printer proxy config:"
cat "$NGINX_UPSTREAMS"
cat "$NGINX_LOCATIONS"

# Add fallback rules for absolute path requests after all printer-specific rules
echo "# Fallback rules for absolute path requests" >> "$NGINX_LOCATIONS"
if [ -f "$PRINTERS_JSON" ]; then
    PRINTER_COUNT=$(jq '.printers | length' "$PRINTERS_JSON" 2>/dev/null || echo 0)
    if [ "$PRINTER_COUNT" -gt 0 ]; then
        # Get the first printer as default fallback
        FIRST_PRINTER=$(jq -c '.printers[0]' "$PRINTERS_JSON" | jq -r '.name' | tr ' ' '_' | tr '[:upper:]' '[:lower:]')
        
        cat >> "$NGINX_LOCATIONS" <<EOF

# Fallback for assets requested with absolute paths
# Route based on referrer header to determine which printer
location ~ ^/(assets|static|css|js|fonts|img|api|printer|websocket|machine|server|access)/(.*) {
    # Default to first printer, but try to detect from referrer
    set \$target_printer "${FIRST_PRINTER}";
    
    # Check referrer to determine correct printer
EOF

        # Add referrer-based routing for each printer
        jq -c '.printers[]' "$PRINTERS_JSON" | while read -r PRN; do
            NAME=$(echo "$PRN" | jq -r '.name' | tr ' ' '_' | tr '[:upper:]' '[:lower:]')
            cat >> "$NGINX_LOCATIONS" <<EOF
    if (\$http_referer ~ "/proxy/${NAME}/") {
        set \$target_printer "${NAME}";
    }
EOF
        done
        
        cat >> "$NGINX_LOCATIONS" <<EOF
    
    # Proxy to the determined printer
    proxy_pass http://\${target_printer}_up/\$1/\$2\$is_args\$args;
    proxy_set_header Host \$http_host;
    proxy_set_header X-Real-IP \$remote_addr;
    proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto \$scheme;
    proxy_http_version 1.1;
    proxy_buffering off;
    
    # Add CORS headers for assets
    add_header Access-Control-Allow-Origin *;
    add_header Access-Control-Allow-Methods "GET, POST, OPTIONS";
    add_header Access-Control-Allow-Headers "DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range";
}
EOF
    fi
fi

# Test connectivity to printer interfaces
echo "[INFO] Testing connectivity to printer interfaces..."
if [ -f "$PRINTERS_JSON" ]; then
    PRINTER_COUNT=$(jq '.printers | length' "$PRINTERS_JSON" 2>/dev/null || echo 0)
    if [ "$PRINTER_COUNT" -gt 0 ]; then
        jq -c '.printers[]' "$PRINTERS_JSON" | while read -r PRN; do
            NAME=$(echo "$PRN" | jq -r '.name')
            URL=$(echo  "$PRN" | jq -r '.url')
            
            if echo "$URL" | grep -qE '^https?://'; then
                echo "[DEBUG] Testing connection to $NAME at $URL..."
                if timeout 5 curl -s -o /dev/null -w "%{http_code}" "$URL" >/dev/null 2>&1; then
                    echo "[INFO] ✓ $NAME ($URL) is reachable"
                else
                    echo "[WARN] ✗ $NAME ($URL) is not reachable - this may cause 404 errors"
                fi
            fi
        done
    fi
fi

echo "[INFO] Using pure proxy approach - no printer-side configuration needed"

# Start nginx in background
echo "[INFO] Starting nginx..."
nginx &

# Function to handle shutdown gracefully
shutdown() {
    echo "[INFO] Shutting down services..."
    pkill -f "python3 app.py" || true
    pkill nginx || true
    exit 0
}

# Trap signals for graceful shutdown
trap shutdown SIGTERM SIGINT

# Start the Flask application in foreground
echo "[INFO] Starting Python Flask backend..."
cd /app
python3 app.py &

# Wait for background processes
wait 